[
  {
    "objectID": "examples/examples.html",
    "href": "examples/examples.html",
    "title": "Jupyter notebook",
    "section": "",
    "text": "genomeinterv provides support for working with intervals on genomes. A genomic interval is specified as a chromosome, start, and end. It is half-open so that a value x is in an interval (start, end) included in the inrval if start &lt;= x and x &lt; end. All functions take pandas.DataFrames as arguments. These data frames must include chrom, start, and end columns.\nSee the library reference for detailed documentation of each function and decorator.\nimport genominterv\nimport pandas as pd",
    "crumbs": [
      "Examples",
      "Jupyter notebook"
    ]
  },
  {
    "objectID": "examples/examples.html#set-operations",
    "href": "examples/examples.html#set-operations",
    "title": "Jupyter notebook",
    "section": "Set operations",
    "text": "Set operations\nThe three functions interval_diff, interval_intersect, and interval_union do the standard difference, intersection and union set operations on two sets of genomic intervals.\nThe intervals returned from all three functions are collapsed to produce non-overlapping intervals. The genomic intervals in each set must be non-overlapping. This can be achieved using function interval_collapse, which produces the union of genomic intervals in a single set genomic of intervals.\nTry it out on two sets of intervals: annot and query:\n\nintervals = [('chr1', 1, 3), ('chr1', 4, 6), ('chr1', 5, 10), ('chr1', 25, 30), ('chr1', 20, 27), ('chr2', 1, 10), ('chr2', 1, 3)]\nannot = pd.DataFrame.from_records(intervals, columns=['chrom', 'start', 'end'])\nannot\n\n\n\n\n\n\n\n\nchrom\nstart\nend\n\n\n\n\n0\nchr1\n1\n3\n\n\n1\nchr1\n4\n6\n\n\n2\nchr1\n5\n10\n\n\n3\nchr1\n25\n30\n\n\n4\nchr1\n20\n27\n\n\n5\nchr2\n1\n10\n\n\n6\nchr2\n1\n3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: Intervals\n\n\n\n\n\n\nintervals = [('chr1', 8, 22), ('chr2', 14, 15)]\nquery = pd.DataFrame.from_records(intervals, columns=['chrom', 'start', 'end'])\nquery\n\n\n\n\n\n\n\n\nchrom\nstart\nend\n\n\n\n\n0\nchr1\n8\n22\n\n\n1\nchr2\n14\n15\n\n\n\n\n\n\n\n\nfrom genominterv import interval_collapse\n\nannot_collapsed = interval_collapse(annot)\nannot_collapsed\n\n\n\n\n\n\n\n\nindex\nstart\nend\nchrom\n\n\n\n\n0\n0\n1\n3\nchr1\n\n\n1\n1\n4\n10\nchr1\n\n\n2\n2\n20\n30\nchr1\n\n\n3\n0\n1\n10\nchr2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2: Collapsed intervals\n\n\n\n\n\n\nannot = annot_collapsed\n\n\nfrom genominterv import interval_diff\n\nnon_ovl_query = interval_diff(query, annot)\nnon_ovl_query\n\n\n\n\n\n\n\n\nindex\nstart\nend\nchrom\n\n\n\n\n0\n0\n10\n20\nchr1\n\n\n1\n0\n14\n15\nchr2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3: Non-overlapping intervals\n\n\n\n\n\n\nfrom genominterv import interval_intersect\n\nintersection = interval_intersect(query, annot)\nintersection\n\n\n\n\n\n\n\n\nindex\nstart\nend\nchrom\n\n\n\n\n0\n0\n8\n10\nchr1\n\n\n1\n1\n20\n22\nchr1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 4: Intersection of intervals\n\n\n\n\n\n\nfrom genominterv import interval_union\n\nunion = interval_union(query, annot)\nunion\n\n\n\n\n\n\n\n\nindex\nstart\nend\nchrom\n\n\n\n\n0\n0\n1\n3\nchr1\n\n\n1\n1\n4\n30\nchr1\n\n\n2\n0\n1\n10\nchr2\n\n\n3\n1\n14\n15\nchr2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 5: Union of intervals\n\n\n\n\n\nTo make it easy to create other interval functions that work across chromosomes, the module provides a genomic decorator that can be applied to functions that operate lists of (start, end) tuples. Applying the decorator changes the signature of a function to make it operate on DataFrames that include chrom, start, and end columns.\nHere is an example function that shifts the interval coordinates by 1000bp:\n\nintervals = pd.DataFrame(dict(chrom='chrX', start=[1, 20], end=[2, 25]))\nintervals\n\n\n\n\n\n\n\n\nchrom\nstart\nend\n\n\n\n\n0\nchrX\n1\n2\n\n\n1\nchrX\n20\n25\n\n\n\n\n\n\n\n\nfrom genominterv import genomic\n\n@genomic\ndef inverval_shift(interv):\n    return [(start+1000, end+1000) for (start, end) in interv]\n\nshifted = inverval_shift(intervals)\nshifted\n\n\n\n\n\n\n\n\nindex\nstart\nend\nchrom\n\n\n\n\n0\n0\n1001\n1002\nchrX\n\n\n1\n1\n1020\n1025\nchrX",
    "crumbs": [
      "Examples",
      "Jupyter notebook"
    ]
  },
  {
    "objectID": "examples/examples.html#remapping-functions",
    "href": "examples/examples.html#remapping-functions",
    "title": "Jupyter notebook",
    "section": "Remapping functions",
    "text": "Remapping functions\nThe function remap converts coordinates a single interval into distance to the closest interval in a second set:\n\nsingle_interval = (300, 400)\nother_intervals = [(0, 100), (1000, 1100)]\n\ngenominterv.remap(single_interval, other_intervals)\n\n[(200, 300)]\n\n\nSame but retaining info about which annotation the interval is proximal to:\n\ngenominterv.remap((300, 400), [(0, 100), (1000, 1100)], include_prox_coord=True)\n\n[(200, 300, 0, 100)]\n\n\nThe function interval_distance converts coordinates of one set of genomic intervals into distances to the closest interval in a second set. interval_relative_distance does the same but returns relative distances.\n\nannot = pd.DataFrame(dict(chrom='chrX', start=[1, 20], end=[2, 25]))\nannot\n\n\n\n\n\n\n\n\nchrom\nstart\nend\n\n\n\n\n0\nchrX\n1\n2\n\n\n1\nchrX\n20\n25\n\n\n\n\n\n\n\n\nquery = pd.DataFrame(dict(chrom='chrX', start=[3, 5], end=[15, 7], some_data=['foo', 'bar'], other_data=['A', 'B']))\nquery\n\n\n\n\n\n\n\n\nchrom\nstart\nend\nsome_data\nother_data\n\n\n\n\n0\nchrX\n3\n15\nfoo\nA\n\n\n1\nchrX\n5\n7\nbar\nB\n\n\n\n\n\n\n\n\nfrom genominterv import interval_distance\n\ninterval_distance(query, annot)\n\n\n\n\n\n\n\n\nindex\nstart\nend\nchrom\n\n\n\n\n0\n0\n1\n9\nchrX\n\n\n1\n1\n-5\n-9\nchrX\n\n\n2\n2\n3\n5\nchrX\n\n\n\n\n\n\n\n\nfrom genominterv import interval_relative_distance\n\ninterval_relative_distance(query, annot)\n\n\n\n\n\n\n\n\nindex\nstart\nend\nchrom\n\n\n\n\n0\n0\n0.055556\n0.500000\nchrX\n\n\n1\n1\n-0.277778\n-0.500000\nchrX\n\n\n2\n2\n0.166667\n0.277778\nchrX\n\n\n\n\n\n\n\nThe most useful function for most applications is remap_interval_data, which does the remapping while preserving all the information in the query data frame. It also reports the start and end coordinates before remapping (ends with *_orig) and the coordinates of the most proximal segment in the annotation set (*_prox).\n\nfrom genominterv import remap_interval_data\n\nremap_interval_data(query, annot)\n\n\n\n\n\n\n\n\nstart\nend\nstart_prox\nend_prox\nchrom\nstart_orig\nend_orig\nsome_data\nother_data\n\n\n\n\n0\n1\n9\n1\n2\nchrX\n3\n15\nfoo\nA\n\n\n1\n-5\n-9\n20\n25\nchrX\n3\n15\nfoo\nA\n\n\n2\n3\n5\n1\n2\nchrX\n5\n7\nbar\nB",
    "crumbs": [
      "Examples",
      "Jupyter notebook"
    ]
  },
  {
    "objectID": "examples/examples.html#ready-made-tests",
    "href": "examples/examples.html#ready-made-tests",
    "title": "Jupyter notebook",
    "section": "Ready-made tests",
    "text": "Ready-made tests\nproximity_test computes tests if intervals in one set is significantly proximal to intervals in another set.\n\nfrom genominterv import proximity_test\n\nannot = pd.DataFrame(dict(chrom='chr1',\n                          start=list(range(1, 1000, 100)),\n                          end=list(range(20, 1020, 100))))\nquery = pd.DataFrame(dict(chrom='chr1',\n                          start=list(range(1, 1000, 10)),\n                          end=list(range(10, 1010, 10))))\n\nThe annotation intervals cannot overlap each other or any of the query intervals:\n\nannot_collapsed = interval_collapse(annot)\nnon_ovl_query = interval_diff(query, annot_collapsed)\n\n\nproximity_test(non_ovl_query, annot_collapsed)\n\nTestResult(statistic=-0.02112359550561797, pvalue=0.6351)",
    "crumbs": [
      "Examples",
      "Jupyter notebook"
    ]
  },
  {
    "objectID": "examples/examples.html#two-set-statistics",
    "href": "examples/examples.html#two-set-statistics",
    "title": "Jupyter notebook",
    "section": "Two-set statistics",
    "text": "Two-set statistics\nThe module also provides two statistics for relations between sets: jaccard computes the Jaccard index statistic for two sets of genomic intervals.\n\nannot = pd.DataFrame(dict(chrom='chrX', start=[2, 9, 20], end=[4, 14, 25], some_data=['foo', 'bar', 'baz']))\nannot\n\n\n\n\n\n\n\n\nchrom\nstart\nend\nsome_data\n\n\n\n\n0\nchrX\n2\n4\nfoo\n\n\n1\nchrX\n9\n14\nbar\n\n\n2\nchrX\n20\n25\nbaz\n\n\n\n\n\n\n\n\nquery = pd.DataFrame(dict(chrom='chrX', start=[3, 7], end=[5, 10], some_data=['foo', 'bar'], other_data=['A', 'B']))\nquery\n\n\n\n\n\n\n\n\nchrom\nstart\nend\nsome_data\nother_data\n\n\n\n\n0\nchrX\n3\n5\nfoo\nA\n\n\n1\nchrX\n7\n10\nbar\nB\n\n\n\n\n\n\n\n\nfrom genominterv import jaccard_stat\n\njaccard_stat(query, annot)\n\n0.13333333333333333",
    "crumbs": [
      "Examples",
      "Jupyter notebook"
    ]
  },
  {
    "objectID": "examples/examples.html#bootstrap-decorator",
    "href": "examples/examples.html#bootstrap-decorator",
    "title": "Jupyter notebook",
    "section": "Bootstrap decorator",
    "text": "Bootstrap decorator\nThe module provides a bootstrap decorator that turns a function producing a statistic into one that also produces a p-value. The bootstrapping resamples the intervals of the second argument for each chromosome independently. Only required argument to bootstrap is the name of the chromosome assembly used. The decorator works on any function that takes two sets of intervals.\nThis example does this for the provided jaccard satistic:\n\nfrom genominterv import bootstrap\n\n@bootstrap('hg19', samples=1000)\ndef jaccard_test(query, annot):\n    return jaccard_stat(query, annot)\n\njaccard_stat, p_value = jaccard_test(query, annot)",
    "crumbs": [
      "Examples",
      "Jupyter notebook"
    ]
  },
  {
    "objectID": "api/interval_intersect.html",
    "href": "api/interval_intersect.html",
    "title": "interval_intersect",
    "section": "",
    "text": "genominterv.interval_intersect(query, annot)\nThis function computes the intersection of two sets of genomic intervals. The genomic intervals in each set must be non-overlapping. This can be achieved using interval_collapse.\n\n\n\nquery : pandas.DataFrame\n\nData frame with query intervals.\n\nannot : pandas.DataFrame\n\nData frame with annotation intervals.\n\n\n\n\n\n\n : pandas.DataFrame\n\nA data frame with chr, start, end columns representing the intersection.\n\n\n\n\n\ngenominterv.intervals.interval_diff, genominterv.intervals.interval_union, genominterv.intervals.interval_collapse.",
    "crumbs": [
      "Genomic set operations",
      "interval_intersect"
    ]
  },
  {
    "objectID": "api/interval_intersect.html#parameters",
    "href": "api/interval_intersect.html#parameters",
    "title": "interval_intersect",
    "section": "",
    "text": "query : pandas.DataFrame\n\nData frame with query intervals.\n\nannot : pandas.DataFrame\n\nData frame with annotation intervals.",
    "crumbs": [
      "Genomic set operations",
      "interval_intersect"
    ]
  },
  {
    "objectID": "api/interval_intersect.html#returns",
    "href": "api/interval_intersect.html#returns",
    "title": "interval_intersect",
    "section": "",
    "text": ": pandas.DataFrame\n\nA data frame with chr, start, end columns representing the intersection.",
    "crumbs": [
      "Genomic set operations",
      "interval_intersect"
    ]
  },
  {
    "objectID": "api/interval_intersect.html#see-also",
    "href": "api/interval_intersect.html#see-also",
    "title": "interval_intersect",
    "section": "",
    "text": "genominterv.intervals.interval_diff, genominterv.intervals.interval_union, genominterv.intervals.interval_collapse.",
    "crumbs": [
      "Genomic set operations",
      "interval_intersect"
    ]
  },
  {
    "objectID": "api/collapse.html",
    "href": "api/collapse.html",
    "title": "collapse",
    "section": "",
    "text": "genominterv.interval_set_op.collapse(a)\nConverts a list of sorted overlapping intervals to non-overlapping intervals spanning each inCollapsed non intervals of two sorted lists of (start, end) intervals.\n\n\n\na : \n\nList of intervals.\n\n\n\n\n\n\n : \n\nList of intervals.",
    "crumbs": [
      "Interval set utilities",
      "collapse"
    ]
  },
  {
    "objectID": "api/collapse.html#parameters",
    "href": "api/collapse.html#parameters",
    "title": "collapse",
    "section": "",
    "text": "a : \n\nList of intervals.",
    "crumbs": [
      "Interval set utilities",
      "collapse"
    ]
  },
  {
    "objectID": "api/collapse.html#returns",
    "href": "api/collapse.html#returns",
    "title": "collapse",
    "section": "",
    "text": ": \n\nList of intervals.",
    "crumbs": [
      "Interval set utilities",
      "collapse"
    ]
  },
  {
    "objectID": "api/diff.html",
    "href": "api/diff.html",
    "title": "diff",
    "section": "",
    "text": "genominterv.interval_set_op.diff(a, b)\nDifference intervals of two sorted lists of (start, end) intervals.\n\n\n\na : list\n\nList of intervals.\n\nb : list\n\nList of intervals.\n\n\n\n\n\n\n : list\n\nList of intervals.",
    "crumbs": [
      "Interval set utilities",
      "diff"
    ]
  },
  {
    "objectID": "api/diff.html#parameters",
    "href": "api/diff.html#parameters",
    "title": "diff",
    "section": "",
    "text": "a : list\n\nList of intervals.\n\nb : list\n\nList of intervals.",
    "crumbs": [
      "Interval set utilities",
      "diff"
    ]
  },
  {
    "objectID": "api/diff.html#returns",
    "href": "api/diff.html#returns",
    "title": "diff",
    "section": "",
    "text": ": list\n\nList of intervals.",
    "crumbs": [
      "Interval set utilities",
      "diff"
    ]
  },
  {
    "objectID": "api/bootstrap.html",
    "href": "api/bootstrap.html",
    "title": "bootstrap",
    "section": "",
    "text": "genominterv.decorators.bootstrap(\n    chromosome_sizes\n    samples=100000\n    smaller=False\n    return_boot=False\n    cores=1\n)\nParameterized decorator that turns a function producing a statistic into one that also produces a p-value from bootstrapping. The bootstrapping resamples the intervals of the first argument for each chromosome independently. Only required argument to bootstrap is the name of the genome assembly used.\n\n\n\nchromosome_sizes : Union[str, dict]\n\nName of a genome assembly or a dictionary mapping chromosomes to their lengths.\n\nsamples : int = 100000\n\nNumber of bootstrap samples to use.\n\nsmaller : bool = False\n\nWhether to test for significantly small values of the statistic rather than large ones.\n\nreturn_boot : bool = False\n\nWhether to return the bootstrap samples too.\n\ncores : int = 1\n\nNumber of CPU cores to use for computation, by default 1.\n\n\n\n\n\n\n : \n\nThe decorated function returns a statistic and a p-value. A decorated function that takes data frames with chrom, start, end columns and executes on each chromosome individually.",
    "crumbs": [
      "Decorators",
      "bootstrap"
    ]
  },
  {
    "objectID": "api/bootstrap.html#parameters",
    "href": "api/bootstrap.html#parameters",
    "title": "bootstrap",
    "section": "",
    "text": "chromosome_sizes : Union[str, dict]\n\nName of a genome assembly or a dictionary mapping chromosomes to their lengths.\n\nsamples : int = 100000\n\nNumber of bootstrap samples to use.\n\nsmaller : bool = False\n\nWhether to test for significantly small values of the statistic rather than large ones.\n\nreturn_boot : bool = False\n\nWhether to return the bootstrap samples too.\n\ncores : int = 1\n\nNumber of CPU cores to use for computation, by default 1.",
    "crumbs": [
      "Decorators",
      "bootstrap"
    ]
  },
  {
    "objectID": "api/bootstrap.html#returns",
    "href": "api/bootstrap.html#returns",
    "title": "bootstrap",
    "section": "",
    "text": ": \n\nThe decorated function returns a statistic and a p-value. A decorated function that takes data frames with chrom, start, end columns and executes on each chromosome individually.",
    "crumbs": [
      "Decorators",
      "bootstrap"
    ]
  },
  {
    "objectID": "api/union.html",
    "href": "api/union.html",
    "title": "union",
    "section": "",
    "text": "genominterv.interval_set_op.union(a, b)\nUnion intervals of two sorted lists of (start, end) intervals.\n\n\n\na : list\n\nList of intervals.\n\nb : list\n\nList of intervals.\n\n\n\n\n\n\n : list\n\nList of intervals.",
    "crumbs": [
      "Interval set utilities",
      "union"
    ]
  },
  {
    "objectID": "api/union.html#parameters",
    "href": "api/union.html#parameters",
    "title": "union",
    "section": "",
    "text": "a : list\n\nList of intervals.\n\nb : list\n\nList of intervals.",
    "crumbs": [
      "Interval set utilities",
      "union"
    ]
  },
  {
    "objectID": "api/union.html#returns",
    "href": "api/union.html#returns",
    "title": "union",
    "section": "",
    "text": ": list\n\nList of intervals.",
    "crumbs": [
      "Interval set utilities",
      "union"
    ]
  },
  {
    "objectID": "api/interval_union.html",
    "href": "api/interval_union.html",
    "title": "interval_union",
    "section": "",
    "text": "genominterv.interval_union(query, annot)\nThis function computes the union of two sets of genomic intervals. The genomic intervals in each set must be non-overlapping. This can be achieved using interval_collapse.\n\n\n\nquery : pandas.DataFrame\n\nData frame with query intervals.\n\nannot : pandas.DataFrame\n\nData frame with annotation intervals.\n\n\n\n\n\n\n : pandas.DataFrame\n\nA data frame with chr, start, end columns representing the union.\n\n\n\n\n\ngenominterv.intervals.interval_diff, genominterv.intervals.interval_intersect, genominterv.intervals.interval_collapse.",
    "crumbs": [
      "Genomic set operations",
      "interval_union"
    ]
  },
  {
    "objectID": "api/interval_union.html#parameters",
    "href": "api/interval_union.html#parameters",
    "title": "interval_union",
    "section": "",
    "text": "query : pandas.DataFrame\n\nData frame with query intervals.\n\nannot : pandas.DataFrame\n\nData frame with annotation intervals.",
    "crumbs": [
      "Genomic set operations",
      "interval_union"
    ]
  },
  {
    "objectID": "api/interval_union.html#returns",
    "href": "api/interval_union.html#returns",
    "title": "interval_union",
    "section": "",
    "text": ": pandas.DataFrame\n\nA data frame with chr, start, end columns representing the union.",
    "crumbs": [
      "Genomic set operations",
      "interval_union"
    ]
  },
  {
    "objectID": "api/interval_union.html#see-also",
    "href": "api/interval_union.html#see-also",
    "title": "interval_union",
    "section": "",
    "text": "genominterv.intervals.interval_diff, genominterv.intervals.interval_intersect, genominterv.intervals.interval_collapse.",
    "crumbs": [
      "Genomic set operations",
      "interval_union"
    ]
  },
  {
    "objectID": "api/jaccard_stat.html",
    "href": "api/jaccard_stat.html",
    "title": "jaccard_stat",
    "section": "",
    "text": "genominterv.stats.jaccard_stat(a, b)\nCompute Jaccard overlap test statistic.\n\n\n\na : List[tuple]\n\nList of tuples with (start, end) coordinates.\n\na : List[tuple]\n\nList of tuples with (start, end) coordinates.\n\n\n\n\n\n\n : float\n\nThe Jaccard test statistic.",
    "crumbs": [
      "Statistics",
      "jaccard_stat"
    ]
  },
  {
    "objectID": "api/jaccard_stat.html#parameters",
    "href": "api/jaccard_stat.html#parameters",
    "title": "jaccard_stat",
    "section": "",
    "text": "a : List[tuple]\n\nList of tuples with (start, end) coordinates.\n\na : List[tuple]\n\nList of tuples with (start, end) coordinates.",
    "crumbs": [
      "Statistics",
      "jaccard_stat"
    ]
  },
  {
    "objectID": "api/jaccard_stat.html#returns",
    "href": "api/jaccard_stat.html#returns",
    "title": "jaccard_stat",
    "section": "",
    "text": ": float\n\nThe Jaccard test statistic.",
    "crumbs": [
      "Statistics",
      "jaccard_stat"
    ]
  },
  {
    "objectID": "api/invert.html",
    "href": "api/invert.html",
    "title": "invert",
    "section": "",
    "text": "genominterv.interval_set_op.invert(a, left, right)\nProduces the complement of a list of sorted intervals limited by the left left and right parameters.\n\n\n\na : list\n\nList of intervals.\n\nleft : int\n\nLeft boundary position.\n\nright : int\n\nLeft boundary position.\n\n\n\n\n\n\n : list\n\nList of intervals.",
    "crumbs": [
      "Interval set utilities",
      "invert"
    ]
  },
  {
    "objectID": "api/invert.html#parameters",
    "href": "api/invert.html#parameters",
    "title": "invert",
    "section": "",
    "text": "a : list\n\nList of intervals.\n\nleft : int\n\nLeft boundary position.\n\nright : int\n\nLeft boundary position.",
    "crumbs": [
      "Interval set utilities",
      "invert"
    ]
  },
  {
    "objectID": "api/invert.html#returns",
    "href": "api/invert.html#returns",
    "title": "invert",
    "section": "",
    "text": ": list\n\nList of intervals.",
    "crumbs": [
      "Interval set utilities",
      "invert"
    ]
  },
  {
    "objectID": "pages/set_operations.html",
    "href": "pages/set_operations.html",
    "title": "Set operations",
    "section": "",
    "text": "The three functions, interval_diff, interval_intersect, and interval_union, do the standard difference, intersection and union set operations on two sets of genomic intervals. The intervals returned from all three functions are collapsed to produce non-overlapping intervals. The genomic intervals in each set must be non-overlapping. This can be achieved using the interval_collapse function, which produces the union of genomic intervals in a single set genomic of intervals.",
    "crumbs": [
      "Set operations",
      "Set operations"
    ]
  },
  {
    "objectID": "pages/set_operations.html#collapse-overlapping-intervals-in-a-list",
    "href": "pages/set_operations.html#collapse-overlapping-intervals-in-a-list",
    "title": "Set operations",
    "section": "Collapse overlapping intervals in a list",
    "text": "Collapse overlapping intervals in a list\n\nintervals = [('chr1', 1, 3), ('chr1', 4, 6), ('chr1', 5, 10), ('chr1', 25, 30), \n             ('chr1', 20, 27), ('chr2', 1, 10), ('chr2', 1, 3)]\nannot = pd.DataFrame.from_records(intervals, columns=['chrom', 'start', 'end'])\nannot\n\n\n\n\n\n\n\n\nchrom\nstart\nend\n\n\n\n\n0\nchr1\n1\n3\n\n\n1\nchr1\n4\n6\n\n\n2\nchr1\n5\n10\n\n\n3\nchr1\n25\n30\n\n\n4\nchr1\n20\n27\n\n\n5\nchr2\n1\n10\n\n\n6\nchr2\n1\n3\n\n\n\n\n\n\n\n\nfrom genominterv import interval_collapse\n\nannot_collapsed = interval_collapse(annot)\nannot_collapsed\n\n\n\n\n\n\n\n\nstart\nend\nchrom\n\n\n\n\n0\n1\n3\nchr1\n\n\n1\n4\n10\nchr1\n\n\n2\n20\n30\nchr1\n\n\n3\n1\n10\nchr2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: Collapsed intervals",
    "crumbs": [
      "Set operations",
      "Set operations"
    ]
  },
  {
    "objectID": "pages/set_operations.html#non-overlap",
    "href": "pages/set_operations.html#non-overlap",
    "title": "Set operations",
    "section": "Non-overlap",
    "text": "Non-overlap\n\nannot = annot_collapsed\n\nintervals = [('chr1', 8, 22), ('chr2', 14, 15)]\nquery = pd.DataFrame.from_records(intervals, columns=['chrom', 'start', 'end'])\nquery\n\n\n\n\n\n\n\n\nchrom\nstart\nend\n\n\n\n\n0\nchr1\n8\n22\n\n\n1\nchr2\n14\n15\n\n\n\n\n\n\n\n\nfrom genominterv.intervals import interval_diff\n\nnon_ovl_query = interval_diff(query, annot)\nnon_ovl_query\n\n\n\n\n\n\n\n\nstart\nend\nchrom\n\n\n\n\n0\n10\n20\nchr1\n\n\n1\n14\n15\nchr2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2: Non-overlapping intervals",
    "crumbs": [
      "Set operations",
      "Set operations"
    ]
  },
  {
    "objectID": "pages/set_operations.html#intersection",
    "href": "pages/set_operations.html#intersection",
    "title": "Set operations",
    "section": "Intersection",
    "text": "Intersection\n\nfrom genominterv import interval_intersect\n\nintersection = interval_intersect(query, annot)\nintersection\n\n\n\n\n\n\n\n\nstart\nend\nchrom\n\n\n\n\n0\n8\n10\nchr1\n\n\n1\n20\n22\nchr1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3: Intersection of intervals",
    "crumbs": [
      "Set operations",
      "Set operations"
    ]
  },
  {
    "objectID": "pages/set_operations.html#union",
    "href": "pages/set_operations.html#union",
    "title": "Set operations",
    "section": "Union",
    "text": "Union\n\nfrom genominterv import interval_union\n\nunion = interval_union(query, annot)\nunion\n\n\n\n\n\n\n\n\nstart\nend\nchrom\n\n\n\n\n0\n1\n3\nchr1\n\n\n1\n4\n30\nchr1\n\n\n2\n1\n10\nchr2\n\n\n3\n14\n15\nchr2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 4: Union of intervals",
    "crumbs": [
      "Set operations",
      "Set operations"
    ]
  },
  {
    "objectID": "pages/decorators.html",
    "href": "pages/decorators.html",
    "title": "Decorators for intervals",
    "section": "",
    "text": "genominterv provides decorators for various tasks to reduce boilerplate code.\nTo make it easy to create other interval functions that work across chromosomes, the module provides a genomic decorator that can be applied to functions that operate lists of (start, end) tuples. Applying the decorator changes the signature of a function to make it operate on DataFrames that include chrom, start, and end columns.\nHere is an example function that shifts the interval coordinates by 1000bp:\nintervals = pd.DataFrame(dict(chrom=['chr1', 'chr2', 'chr2'], start=[10, 20, 30], end=[15, 25, 35]))\nintervals\n\n\n\n\n\n\n\n\nchrom\nstart\nend\n\n\n\n\n0\nchr1\n10\n15\n\n\n1\nchr2\n20\n25\n\n\n2\nchr2\n30\n35\nCreate a function that shifts intervals three bases to the right:\nfrom genominterv.decorators import genomic\n\n@genomic\ndef shift_three(interv):\n    return [(start+3, end+3) for (start, end) in interv]\n\nshifted = shift_three(intervals)\nshifted\n\n\n\n\n\n\n\n\nstart\nend\nchrom\n\n\n\n\n0\n13\n18\nchr1\n\n\n1\n23\n28\nchr2\n\n\n2\n33\n38\nchr2",
    "crumbs": [
      "Set operations",
      "Decorators for intervals"
    ]
  },
  {
    "objectID": "pages/decorators.html#bootstrap-decorator",
    "href": "pages/decorators.html#bootstrap-decorator",
    "title": "Decorators for intervals",
    "section": "Bootstrap decorator",
    "text": "Bootstrap decorator\nThe bootstrap decorator turns a function producing a statistic into one that also produces a p-value. Only required argument to bootstrap is the name of the chromosome assembly used. The decorator works on any function that takes two sets of intervals. Here it is used with the jaccard_stat statistic to make a jaccard_test function that produce a p-value for the significane of overlap between two sets.\n\nannot = pd.DataFrame(dict(chrom=['chr1', 'chr2', 'chr3'], start=[30_000_000, 120_000_000, 120_000_000], \n                                        end=[60_000_000, 100_000_000, 150_000_000]))\nquery = pd.DataFrame(dict(chrom=['chr1', 'chr3'], start=[20_000_000, 110_000_000], \n                          end=[50_000_000, 160_000_000]))\n\n\nfrom genominterv.decorators import bootstrap\nfrom genominterv.stats import jaccard_stat\n\n@bootstrap('hg38', samples=1000)\ndef jaccard_test(query, annot):\n    return jaccard_stat(query, annot)\n\nstat, p_value = jaccard_test(query, annot)\nstat, p_value\n\n(0.5555555555555556, 0.017)\n\n\nThe bootstrapping shuffles and repositions the intervals of the query argument for each chromosome independently.\n\n\n\n\n\n\n\n\nFigure 1: Example of intervals\n\n\n\n\n\nFor the above set of intervals, the first ten bootstraps could be the ones shown below:\n\n\n\n\n\n\n\n\nFigure 2: Ten bootstraps",
    "crumbs": [
      "Set operations",
      "Decorators for intervals"
    ]
  },
  {
    "objectID": "pages/getting_started.html",
    "href": "pages/getting_started.html",
    "title": "Getting started",
    "section": "",
    "text": "Warning\n\n\n\nThe proximity_test is broken. Do not use for the time being.\n\n\ngenomeinterv provides support for working with intervals on genomes. A genomic interval is specified as a chromosome, start, and end. It is half-open so that a value x is in an interval (start, end) included in the inrval if start &lt;= x and x &lt; end. All functions take pandas.DataFrame as arguments. These data frames must include chrom, start, and end columns.\nasdf\nSee the the library reference for detailed documentation of each function and decorator.",
    "crumbs": [
      "Getting started"
    ]
  },
  {
    "objectID": "pages/remapping.html",
    "href": "pages/remapping.html",
    "title": "Mapping",
    "section": "",
    "text": "The function interval_distance converts coordinates of one set of genomic intervals into distances to the closest interval in a second set.",
    "crumbs": [
      "Remapping",
      "Mapping"
    ]
  },
  {
    "objectID": "pages/remapping.html#remapping-functions",
    "href": "pages/remapping.html#remapping-functions",
    "title": "Mapping",
    "section": "Remapping functions",
    "text": "Remapping functions\nThe function remap converts coordinates a single interval into distance to the closest interval in a second set:\n\nfrom genominterv.remapping import remap\n\nsingle_interval = (300, 400)\nother_intervals = [(0, 100), (1000, 1100)]\n\nremap(single_interval, other_intervals)\n\n[(200, 300)]\n\n\nSame but retaining info about which annotation the interval is proximal to:\n\nremap((300, 400), [(0, 100), (1000, 1100)], include_prox_coord=True)\n\n[(200, 300, 0, 100)]\n\n\nThe function interval_distance converts coordinates of one set of genomic intervals into distances to the closest interval in a second set. Using relative=True returns distances relative to the span between the two flanking annotation intervals.\n\nannot = pd.DataFrame(dict(chrom='chrX', start=[1, 20], end=[2, 25]))\nannot\n\n\n\n\n\n\n\n\nchrom\nstart\nend\n\n\n\n\n0\nchrX\n1\n2\n\n\n1\nchrX\n20\n25\n\n\n\n\n\n\n\n\nquery = pd.DataFrame(dict(chrom='chrX', start=[3, 5], end=[15, 7], some_data=['foo', 'bar'], other_data=['A', 'B']))\nquery\n\n\n\n\n\n\n\n\nchrom\nstart\nend\nsome_data\nother_data\n\n\n\n\n0\nchrX\n3\n15\nfoo\nA\n\n\n1\nchrX\n5\n7\nbar\nB\n\n\n\n\n\n\n\n\nfrom genominterv.remapping import interval_distance\n\ninterval_distance(query, annot)\n\n\n\n\n\n\n\n\nstart\nend\nchrom\n\n\n\n\n0\n1\n9.0\nchrX\n\n\n1\n-5\n-9.0\nchrX\n\n\n2\n3\n5.0\nchrX\n\n\n\n\n\n\n\n\nfrom genominterv.remapping import interval_distance\nimport genominterv\nprint(genominterv.__file__)\ninterval_distance(query, annot, relative=True)\n\n/Users/kmt/genominterv/genominterv/__init__.py\n\n\n\n\n\n\n\n\n\nstart\nend\nchrom\n\n\n\n\n0\n0.055556\n0.500000\nchrX\n\n\n1\n-0.277778\n-0.500000\nchrX\n\n\n2\n0.166667\n0.277778\nchrX\n\n\n\n\n\n\n\nThe most useful function for most applications is remap_interval_data, which does the remapping while preserving all the information in the query data frame. It also reports the start and end coordinates before remapping (ends with *_orig) and the coordinates of the most proximal segment in the annotation set (*_prox).\n\nfrom genominterv.remapping import remap_interval_data\nremap_interval_data(query, annot)\n\n\n\n\n\n\n\n\nstart\nend\nstart_prox\nend_prox\nchrom\nstart_orig\nend_orig\nsome_data\nother_data\n\n\n\n\n0\n1\n9.0\n1\n2\nchrX\n3\n15\nfoo\nA\n\n\n1\n-5\n-9.0\n20\n25\nchrX\n3\n15\nfoo\nA\n\n\n2\n3\n5.0\n1\n2\nchrX\n5\n7\nbar\nB\n\n\n\n\n\n\n\n\nremap_interval_data(query, annot, relative=True)\n\n\n\n\n\n\n\n\nstart\nend\nstart_prox\nend_prox\nchrom\nstart_orig\nend_orig\nsome_data\nother_data\n\n\n\n\n0\n0.055556\n0.500000\n1\n2\nchrX\n3\n15\nfoo\nA\n\n\n1\n-0.277778\n-0.500000\n20\n25\nchrX\n3\n15\nfoo\nA\n\n\n2\n0.166667\n0.277778\n1\n2\nchrX\n5\n7\nbar\nB\n\n\n\n\n\n\n\nMake random and non-random dummy data and plot the relative distances between interval midpoints and the closest annotation interval.\n\nimport seaborn as sns\n\nn = 1000\na = np.sort(np.random.randint(1, 10_000_000, size=n))\nannot = pd.DataFrame(dict(chrom='chrX', start=a, end=a+10))\nq = np.sort(np.random.randint(1, 10_000_000, size=n))\nquery = pd.DataFrame(dict(chrom='chrX', start=q, end=q+10))\ndf1 = remap_interval_data(query, annot, relative=True)\ndf1['mid'] = (df1.start + df1.end) / 2\ndf1['absmid'] = df1.mid.abs()\n\n# dummy data\na = np.sort(np.random.randint(1, 10_000_000, size=n))\nannot = pd.DataFrame(dict(chrom='chrX', start=a, end=a+10))\nq = a + np.random.randint(-1000, 1000, size=n)\nquery = pd.DataFrame(dict(chrom='chrX', start=q, end=q+10))\ndf2 = remap_interval_data(query, annot, relative=True)\ndf2['mid'] = (df2.start + df2.end) / 2\ndf2['absmid'] = df2.mid.abs()\n\n\nsns.histplot(df1, x='start', bins=np.linspace(-0.5, 0.5, 20))\nsns.histplot(df2, x='start', bins=np.linspace(-0.5, 0.5, 20))\n\n\n\n\n\n\n\n\n\nsns.histplot(df1, x='mid', bins=np.linspace(-0.5, 0.5, 20))\nsns.histplot(df2, x='mid', bins=np.linspace(-0.5, 0.5, 20))\n\n\n\n\n\n\n\n\nThe same but removing the sign since the distribution is symmetric:\n\nsns.histplot(df1, x='absmid', bins=np.linspace(0, 0.5, 20))\nsns.histplot(df2, x='absmid', bins=np.linspace(0, 0.5, 20))\n\n\n\n\n\n\n\n\n\ndf1['dist'] = 'uniform'\ndf2['dist'] = 'closer'\ndf = pd.concat([df1, df2])\nsns.barplot(df, y='absmid', x='dist', hue='dist')\n\n\n\n\n\n\n\n\n\nimport seaborn as sns\n\n# dummy data\nn = 1000\na = np.sort(np.random.randint(1, 10_000_000, size=n))\nannot = pd.DataFrame(dict(chrom='chrX', start=a, end=a+10))\nq = a + np.random.randint(-1000, 1000, size=n)\nquery = pd.DataFrame(dict(chrom='chrX', start=q, end=q+10))\ndf = remap_interval_data(query, annot, relative=True)\n\n\ndf['mid'] = (df.start + df.end) / 2\nsns.histplot(df, x='mid', bins=np.linspace(-0.5, 0.5, 20))",
    "crumbs": [
      "Remapping",
      "Mapping"
    ]
  },
  {
    "objectID": "pages/interval_tests.html",
    "href": "pages/interval_tests.html",
    "title": "Interval tests",
    "section": "",
    "text": "genomeinterv implements tests for a significant relationship between sets of intervals.",
    "crumbs": [
      "Remapping",
      "Interval tests"
    ]
  },
  {
    "objectID": "pages/interval_tests.html#proximity",
    "href": "pages/interval_tests.html#proximity",
    "title": "Interval tests",
    "section": "Proximity",
    "text": "Proximity\nproximity_test computes tests if intervals in one set is significantly proximal to intervals in another set.\n\nannot = pd.DataFrame(dict(chrom='chr1', \n                          start=[38_000_000, 100_000_000, 175_000_000], \n                          end=[40_000_000, 103_000_000, 178_000_000]))\nquery = pd.DataFrame(dict(chrom='chr1', \n                          start=[41_000_000, 105_000_000, 170_000_000], \n                          end=[40_500_000, 106_000_000, 173_000_000]))\n\n\n\n\n\n\n\n\n\nFigure 1: Intervals\n\n\n\n\n\nWith the multiprocess library installed:\nconda install conda-forge::multiprocess\nyou can run the permutation test on all the cores you have:\n\nfrom genominterv.stats import proximity_test\n\nstat, pvalue = proximity_test(query, annot, cores=8)\npvalue\n\n0.0",
    "crumbs": [
      "Remapping",
      "Interval tests"
    ]
  },
  {
    "objectID": "pages/interval_tests.html#overlap",
    "href": "pages/interval_tests.html#overlap",
    "title": "Interval tests",
    "section": "Overlap",
    "text": "Overlap\njaccard_stat computes the Jaccard index statistic for two sets of genomic intervals.\nThis can be combined with the bootstrap decorator to produce a test for overlap. The decorator turns a function producing a statistic into one that also produces a p-value. The bootstrapping resamples the intervals of the second argument for each chromosome independently. Only required argument to bootstrap is the name of the chromosome assembly used.\n\nannot = pd.DataFrame(dict(chrom='chr1', \n                          start=[18_000_000, 58_000_000, 138_000_000], \n                          end=[20_000_000, 60_000_000, 140_000_000]))\nquery = pd.DataFrame(dict(chrom='chr1', \n                          start=[41_000_000, 59_000_000, 241_000_000], \n                          end=[40_500_000, 61_000_000, 241_000_000]))\n\n\n\n\n\n\n\n\n\nFigure 2: Intervals\n\n\n\n\n\nWith the multiprocess library installed:\nconda install conda-forge::multiprocess\nyou can run the bootstrapping on all the cores you have:\n\nfrom genominterv.decorators import bootstrap\nfrom genominterv.stats import jaccard_stat\n\n@bootstrap('hg19', cores=8)\ndef jaccard_test(q, a):\n    return jaccard_stat(q, a)\n\nstat, p_value = jaccard_test(query, annot)\nstat, p_value \n\n(0.15384615384615385, 0.03012)",
    "crumbs": [
      "Remapping",
      "Interval tests"
    ]
  },
  {
    "objectID": "api/remap_interval_data.html",
    "href": "api/remap_interval_data.html",
    "title": "remap_interval_data",
    "section": "",
    "text": "genominterv.remapping.remap_interval_data(\n    query\n    annot\n    relative=False\n    overlap_as_zero=False\n    span_as_zero=False\n)\nComputes the distance from each query interval to the closest interval in annot. Original coordinates are preserved as orig_start and orig_end columns. If a query interval overlaps the midpoint between two annot intervals it is split into two intervals proximal to each annot interval, thus contributing two rows to the returned data frame. Intervals from query that overlap intervals in annot are discarded.\n\n\n\nquery : pandas.DataFrame\n\nData frame with query intervals.\n\nannot : pandas.DataFrame\n\nData frame with annotation intervals.\n\nrelative : bool = False\n\nReturn relative distance (0-1) instead of absolute distance, by default False.\n\noverlap_as_zero : bool = False\n\nSet distance to zero if one end of a query segment overlaps an annotation segment, by default False. This does not apply to query segments embedded in or spanning on or more annotation segments.\n\nspan_as_zero : bool = False\n\nSet distance to zero if a query segment spans a single annotation segment, by default False.\n\n\n\n\n\n\n : pandas.DataFrame\n\nA data frame with remapped intervals.\n\n\n\n\n\nIf you do not want to retain the original columns in query, use interval_distance.",
    "crumbs": [
      "Remapping",
      "remap_interval_data"
    ]
  },
  {
    "objectID": "api/remap_interval_data.html#parameters",
    "href": "api/remap_interval_data.html#parameters",
    "title": "remap_interval_data",
    "section": "",
    "text": "query : pandas.DataFrame\n\nData frame with query intervals.\n\nannot : pandas.DataFrame\n\nData frame with annotation intervals.\n\nrelative : bool = False\n\nReturn relative distance (0-1) instead of absolute distance, by default False.\n\noverlap_as_zero : bool = False\n\nSet distance to zero if one end of a query segment overlaps an annotation segment, by default False. This does not apply to query segments embedded in or spanning on or more annotation segments.\n\nspan_as_zero : bool = False\n\nSet distance to zero if a query segment spans a single annotation segment, by default False.",
    "crumbs": [
      "Remapping",
      "remap_interval_data"
    ]
  },
  {
    "objectID": "api/remap_interval_data.html#returns",
    "href": "api/remap_interval_data.html#returns",
    "title": "remap_interval_data",
    "section": "",
    "text": ": pandas.DataFrame\n\nA data frame with remapped intervals.",
    "crumbs": [
      "Remapping",
      "remap_interval_data"
    ]
  },
  {
    "objectID": "api/remap_interval_data.html#see-also",
    "href": "api/remap_interval_data.html#see-also",
    "title": "remap_interval_data",
    "section": "",
    "text": "If you do not want to retain the original columns in query, use interval_distance.",
    "crumbs": [
      "Remapping",
      "remap_interval_data"
    ]
  },
  {
    "objectID": "api/remap.html",
    "href": "api/remap.html",
    "title": "remap",
    "section": "",
    "text": "genominterv.remapping.remap(\n    query\n    annot\n    relative=False\n    include_prox_coord=False\n    overlap_as_zero=False\n    span_as_zero=False\n)\nRemap the coordinates of a single interval in query to the distance from the closet interval in annot. Returns empty set if annot is empty for the chromosome. Intervals from query that overlap intervals in annot are discarded.\n\n\n\nquery : Tuple[int]\n\nQuery interval. A tuple of (start, end) coordinates.\n\nannot : List[tuple]\n\nData frame with annotation intervals. A list of tuples with (start, end) coordinates.\n\nrelative :  = False\n\nReturn relative distance (0-1) instead of absolute distance, by default False.\n\ninclude_prox_coord :  = False\n\nInclude coordinates of the closest annotation segment, by default False.\n\noverlap_as_zero :  = False\n\nSet distance to zero if one end of a query segment overlaps an annotation segment, by default False. This does not apply to query segments embedded in or spanning on or more annotation segments.\n\nspan_as_zero :  = False\n\nSet distance to zero if a query segment spans a single annotation segment, by default False.\n\n\n\n\n\n\n : List[tuple]\n\nA list of tuples with (start, end) coordinates.",
    "crumbs": [
      "Interval mapping utilities",
      "remap"
    ]
  },
  {
    "objectID": "api/remap.html#parameters",
    "href": "api/remap.html#parameters",
    "title": "remap",
    "section": "",
    "text": "query : Tuple[int]\n\nQuery interval. A tuple of (start, end) coordinates.\n\nannot : List[tuple]\n\nData frame with annotation intervals. A list of tuples with (start, end) coordinates.\n\nrelative :  = False\n\nReturn relative distance (0-1) instead of absolute distance, by default False.\n\ninclude_prox_coord :  = False\n\nInclude coordinates of the closest annotation segment, by default False.\n\noverlap_as_zero :  = False\n\nSet distance to zero if one end of a query segment overlaps an annotation segment, by default False. This does not apply to query segments embedded in or spanning on or more annotation segments.\n\nspan_as_zero :  = False\n\nSet distance to zero if a query segment spans a single annotation segment, by default False.",
    "crumbs": [
      "Interval mapping utilities",
      "remap"
    ]
  },
  {
    "objectID": "api/remap.html#returns",
    "href": "api/remap.html#returns",
    "title": "remap",
    "section": "",
    "text": ": List[tuple]\n\nA list of tuples with (start, end) coordinates.",
    "crumbs": [
      "Interval mapping utilities",
      "remap"
    ]
  },
  {
    "objectID": "api/proximity_test.html",
    "href": "api/proximity_test.html",
    "title": "proximity_test",
    "section": "",
    "text": "genominterv.stats.proximity_test(\n    query\n    annot\n    samples=10000\n    npoints=1000\n    overlap_as_zero=False\n    span_as_zero=False\n    two_sided=False\n    cores=1\n)\nTest for proximity of intervals to a set of annotations.\n\n\n\nquery : pd.DataFrame\n\nData frame with query intervals.\n\nannot : pd.DataFrame\n\nData frame with annotation intervals.\n\nsamples : int = 10000\n\nNumber of bootstrap samples to use.\n\nnpoints : int = 1000\n\nNumber of points to use in the ECDF.\n\ntwo_sided : bool = False\n\nWhether to test for proximity in both directions.\n\noverlap_as_zero : bool = False\n\nSet distance to zero if one end of a query segment overlaps an annotation segment, by default False. This does not apply to query segments embedded in or spanning one or more annotation segments.\n\nspan_as_zero : bool = False\n\nSet distance to zero if a query segment spans a single annotation segment, by default False.\n\n\n\n\n\n\n : namedtuple\n\nA named tuple with the test statistic and p-value.",
    "crumbs": [
      "Statistics",
      "proximity_test"
    ]
  },
  {
    "objectID": "api/proximity_test.html#parameters",
    "href": "api/proximity_test.html#parameters",
    "title": "proximity_test",
    "section": "",
    "text": "query : pd.DataFrame\n\nData frame with query intervals.\n\nannot : pd.DataFrame\n\nData frame with annotation intervals.\n\nsamples : int = 10000\n\nNumber of bootstrap samples to use.\n\nnpoints : int = 1000\n\nNumber of points to use in the ECDF.\n\ntwo_sided : bool = False\n\nWhether to test for proximity in both directions.\n\noverlap_as_zero : bool = False\n\nSet distance to zero if one end of a query segment overlaps an annotation segment, by default False. This does not apply to query segments embedded in or spanning one or more annotation segments.\n\nspan_as_zero : bool = False\n\nSet distance to zero if a query segment spans a single annotation segment, by default False.",
    "crumbs": [
      "Statistics",
      "proximity_test"
    ]
  },
  {
    "objectID": "api/proximity_test.html#returns",
    "href": "api/proximity_test.html#returns",
    "title": "proximity_test",
    "section": "",
    "text": ": namedtuple\n\nA named tuple with the test statistic and p-value.",
    "crumbs": [
      "Statistics",
      "proximity_test"
    ]
  },
  {
    "objectID": "api/genomic.html",
    "href": "api/genomic.html",
    "title": "genomic",
    "section": "",
    "text": "genominterv.decorators.genomic(func)\nDecorator for converting a function operating on lists of (start, end) tuples to one that takes data frames with chrom, start, end columns and executes on each chromosome individually.\n\n\n\nfunc : Callable\n\nFunction accepting (start, end) tuples.\n\n\n\n\n\n\n : Callable\n\nA decorated function that takes data frames with chrom, start, end columns and executes on each chromosome individually.",
    "crumbs": [
      "Decorators",
      "genomic"
    ]
  },
  {
    "objectID": "api/genomic.html#parameters",
    "href": "api/genomic.html#parameters",
    "title": "genomic",
    "section": "",
    "text": "func : Callable\n\nFunction accepting (start, end) tuples.",
    "crumbs": [
      "Decorators",
      "genomic"
    ]
  },
  {
    "objectID": "api/genomic.html#returns",
    "href": "api/genomic.html#returns",
    "title": "genomic",
    "section": "",
    "text": ": Callable\n\nA decorated function that takes data frames with chrom, start, end columns and executes on each chromosome individually.",
    "crumbs": [
      "Decorators",
      "genomic"
    ]
  },
  {
    "objectID": "api/index.html",
    "href": "api/index.html",
    "title": "Function reference",
    "section": "",
    "text": "Set operations on pandas.DataFrames with columns for chromosome, start, and end.\n\n\n\ninterval_diff\nThis function computes the difference between two sets of genomic intervals.\n\n\ninterval_union\nThis function computes the union of two sets of genomic intervals. The genomic intervals\n\n\ninterval_intersect\nThis function computes the intersection of two sets of genomic intervals. The genomic intervals\n\n\ninterval_collapse\nThis function computes the union of intervals in a single set.\n\n\n\n\n\n\nMapping intervals relative to other coordinates.\n\n\n\ninterval_distance\nComputes the distance from each query interval to the closest interval in\n\n\nremap_interval_data\nComputes the distance from each query interval to the closest interval\n\n\n\n\n\n\nMapping intervals relative to other coordinates.\n\n\n\nproximity_test\nTest for proximity of intervals to a set of annotations.\n\n\njaccard_stat\nCompute Jaccard overlap test statistic.\n\n\n\n\n\n\nUtilities for user created genomic intervals and bootstrap tests.\n\n\n\ngenomic\nDecorator for converting a function operating on lists of (start, end) tuples to one\n\n\nbootstrap\nParameterized decorator that turns a function producing a statistic into one that also\n\n\n\n\n\n\nSet operations on sorted lists of (start, end) tuples.\n\n\n\nunion\nUnion intervals of two sorted lists of (start, end) intervals.\n\n\ndiff\nDifference intervals of two sorted lists of (start, end) intervals.\n\n\ninvert\nProduces the complement of a list of sorted intervals\n\n\nintersect\nIntersection intervals of two sorted lists of (start, end) intervals.\n\n\ncollapse\nConverts a list of sorted overlapping intervals to non-overlapping\n\n\n\n\n\n\nSet operations on sorted lists of (start, end) tuples.\n\n\n\nremap\nRemap the coordinates of a single interval in query to the distance from",
    "crumbs": [
      "Function reference"
    ]
  },
  {
    "objectID": "api/index.html#genomic-set-operations",
    "href": "api/index.html#genomic-set-operations",
    "title": "Function reference",
    "section": "",
    "text": "Set operations on pandas.DataFrames with columns for chromosome, start, and end.\n\n\n\ninterval_diff\nThis function computes the difference between two sets of genomic intervals.\n\n\ninterval_union\nThis function computes the union of two sets of genomic intervals. The genomic intervals\n\n\ninterval_intersect\nThis function computes the intersection of two sets of genomic intervals. The genomic intervals\n\n\ninterval_collapse\nThis function computes the union of intervals in a single set.",
    "crumbs": [
      "Function reference"
    ]
  },
  {
    "objectID": "api/index.html#remapping",
    "href": "api/index.html#remapping",
    "title": "Function reference",
    "section": "",
    "text": "Mapping intervals relative to other coordinates.\n\n\n\ninterval_distance\nComputes the distance from each query interval to the closest interval in\n\n\nremap_interval_data\nComputes the distance from each query interval to the closest interval",
    "crumbs": [
      "Function reference"
    ]
  },
  {
    "objectID": "api/index.html#statistics",
    "href": "api/index.html#statistics",
    "title": "Function reference",
    "section": "",
    "text": "Mapping intervals relative to other coordinates.\n\n\n\nproximity_test\nTest for proximity of intervals to a set of annotations.\n\n\njaccard_stat\nCompute Jaccard overlap test statistic.",
    "crumbs": [
      "Function reference"
    ]
  },
  {
    "objectID": "api/index.html#decorators",
    "href": "api/index.html#decorators",
    "title": "Function reference",
    "section": "",
    "text": "Utilities for user created genomic intervals and bootstrap tests.\n\n\n\ngenomic\nDecorator for converting a function operating on lists of (start, end) tuples to one\n\n\nbootstrap\nParameterized decorator that turns a function producing a statistic into one that also",
    "crumbs": [
      "Function reference"
    ]
  },
  {
    "objectID": "api/index.html#interval-set-utilities",
    "href": "api/index.html#interval-set-utilities",
    "title": "Function reference",
    "section": "",
    "text": "Set operations on sorted lists of (start, end) tuples.\n\n\n\nunion\nUnion intervals of two sorted lists of (start, end) intervals.\n\n\ndiff\nDifference intervals of two sorted lists of (start, end) intervals.\n\n\ninvert\nProduces the complement of a list of sorted intervals\n\n\nintersect\nIntersection intervals of two sorted lists of (start, end) intervals.\n\n\ncollapse\nConverts a list of sorted overlapping intervals to non-overlapping",
    "crumbs": [
      "Function reference"
    ]
  },
  {
    "objectID": "api/index.html#interval-mapping-utilities",
    "href": "api/index.html#interval-mapping-utilities",
    "title": "Function reference",
    "section": "",
    "text": "Set operations on sorted lists of (start, end) tuples.\n\n\n\nremap\nRemap the coordinates of a single interval in query to the distance from",
    "crumbs": [
      "Function reference"
    ]
  },
  {
    "objectID": "api/interval_distance.html",
    "href": "api/interval_distance.html",
    "title": "interval_distance",
    "section": "",
    "text": "genominterv.remapping.interval_distance(\n    query\n    annot\n    relative=False\n    overlap_as_zero=False\n    span_as_zero=False\n)\nComputes the distance from each query interval to the closest interval in annot. If a query interval overlaps the midpoint between two annot intervals it is split into two intervals proximal to each annot interval. Intervals from query that overlap intervals in annot are discarded.\n\n\n\nquery : pandas.DataFrame\n\nData frame with query intervals.\n\nannot : pandas.DataFrame\n\nData frame with annotation intervals.\n\nrelative : bool = False\n\nReturn relative distance (0-1) instead of absolute distance, by default False.\n\noverlap_as_zero : bool = False\n\nSet distance to zero if one end of a query segment overlaps an annotation segment, by default False. This does not apply to query segments embedded in or spanning on or more annotation segments.\n\nspan_as_zero : bool = False\n\nSet distance to zero if a query segment spans a single annotation segment, by default False.\n\n\n\n\n\n\n : pandas.DataFrame\n\nA data frame with remapped intervals.\n\n\n\n\n\nIf you want to retain the original columns in query, use remap_interval_data.",
    "crumbs": [
      "Remapping",
      "interval_distance"
    ]
  },
  {
    "objectID": "api/interval_distance.html#parameters",
    "href": "api/interval_distance.html#parameters",
    "title": "interval_distance",
    "section": "",
    "text": "query : pandas.DataFrame\n\nData frame with query intervals.\n\nannot : pandas.DataFrame\n\nData frame with annotation intervals.\n\nrelative : bool = False\n\nReturn relative distance (0-1) instead of absolute distance, by default False.\n\noverlap_as_zero : bool = False\n\nSet distance to zero if one end of a query segment overlaps an annotation segment, by default False. This does not apply to query segments embedded in or spanning on or more annotation segments.\n\nspan_as_zero : bool = False\n\nSet distance to zero if a query segment spans a single annotation segment, by default False.",
    "crumbs": [
      "Remapping",
      "interval_distance"
    ]
  },
  {
    "objectID": "api/interval_distance.html#returns",
    "href": "api/interval_distance.html#returns",
    "title": "interval_distance",
    "section": "",
    "text": ": pandas.DataFrame\n\nA data frame with remapped intervals.",
    "crumbs": [
      "Remapping",
      "interval_distance"
    ]
  },
  {
    "objectID": "api/interval_distance.html#see-also",
    "href": "api/interval_distance.html#see-also",
    "title": "interval_distance",
    "section": "",
    "text": "If you want to retain the original columns in query, use remap_interval_data.",
    "crumbs": [
      "Remapping",
      "interval_distance"
    ]
  },
  {
    "objectID": "api/interval_collapse.html",
    "href": "api/interval_collapse.html",
    "title": "interval_collapse",
    "section": "",
    "text": "genominterv.interval_collapse(interv)\nThis function computes the union of intervals in a single set.\n\n\n\ninterv : pandas.DataFrame\n\nData frame with intervals.\n\n\n\n\n\n\n : pandas.DataFrame\n\nA data frame with chr, start, end columns representing the union.\n\n\n\n\n\ngenominterv.intervals.interval_diff, genominterv.intervals.interval_union, genominterv.intervals.interval_intersect.",
    "crumbs": [
      "Genomic set operations",
      "interval_collapse"
    ]
  },
  {
    "objectID": "api/interval_collapse.html#parameters",
    "href": "api/interval_collapse.html#parameters",
    "title": "interval_collapse",
    "section": "",
    "text": "interv : pandas.DataFrame\n\nData frame with intervals.",
    "crumbs": [
      "Genomic set operations",
      "interval_collapse"
    ]
  },
  {
    "objectID": "api/interval_collapse.html#returns",
    "href": "api/interval_collapse.html#returns",
    "title": "interval_collapse",
    "section": "",
    "text": ": pandas.DataFrame\n\nA data frame with chr, start, end columns representing the union.",
    "crumbs": [
      "Genomic set operations",
      "interval_collapse"
    ]
  },
  {
    "objectID": "api/interval_collapse.html#see-also",
    "href": "api/interval_collapse.html#see-also",
    "title": "interval_collapse",
    "section": "",
    "text": "genominterv.intervals.interval_diff, genominterv.intervals.interval_union, genominterv.intervals.interval_intersect.",
    "crumbs": [
      "Genomic set operations",
      "interval_collapse"
    ]
  },
  {
    "objectID": "api/intersect.html",
    "href": "api/intersect.html",
    "title": "intersect",
    "section": "",
    "text": "genominterv.interval_set_op.intersect(a, b)\nIntersection intervals of two sorted lists of (start, end) intervals.\n\n\n\na : list\n\nList of intervals.\n\nb : list\n\nList of intervals.\n\n\n\n\n\n\n : list\n\nList of intervals.",
    "crumbs": [
      "Interval set utilities",
      "intersect"
    ]
  },
  {
    "objectID": "api/intersect.html#parameters",
    "href": "api/intersect.html#parameters",
    "title": "intersect",
    "section": "",
    "text": "a : list\n\nList of intervals.\n\nb : list\n\nList of intervals.",
    "crumbs": [
      "Interval set utilities",
      "intersect"
    ]
  },
  {
    "objectID": "api/intersect.html#returns",
    "href": "api/intersect.html#returns",
    "title": "intersect",
    "section": "",
    "text": ": list\n\nList of intervals.",
    "crumbs": [
      "Interval set utilities",
      "intersect"
    ]
  },
  {
    "objectID": "api/interval_diff.html",
    "href": "api/interval_diff.html",
    "title": "interval_diff",
    "section": "",
    "text": "genominterv.interval_diff(query, annot)\nThis function computes the difference between two sets of genomic intervals. The genomic intervals in each set must be non-overlapping. This can be achieved using :any:interval_collapse.\n\n\n\nquery : pandas.DataFrame\n\nData frame with query intervals.\n\nannot : pandas.DataFrame\n\nData frame with annotation intervals.\n\n\n\n\n\n\n : pandas.DataFrame\n\nA data frame with chr, start, end columns representing the difference.\n\n\n\n\n\ngenominterv.intervals.interval_union, genominterv.intervals.interval_intersect, genominterv.intervals.interval_collapse.",
    "crumbs": [
      "Genomic set operations",
      "interval_diff"
    ]
  },
  {
    "objectID": "api/interval_diff.html#parameters",
    "href": "api/interval_diff.html#parameters",
    "title": "interval_diff",
    "section": "",
    "text": "query : pandas.DataFrame\n\nData frame with query intervals.\n\nannot : pandas.DataFrame\n\nData frame with annotation intervals.",
    "crumbs": [
      "Genomic set operations",
      "interval_diff"
    ]
  },
  {
    "objectID": "api/interval_diff.html#returns",
    "href": "api/interval_diff.html#returns",
    "title": "interval_diff",
    "section": "",
    "text": ": pandas.DataFrame\n\nA data frame with chr, start, end columns representing the difference.",
    "crumbs": [
      "Genomic set operations",
      "interval_diff"
    ]
  },
  {
    "objectID": "api/interval_diff.html#see-also",
    "href": "api/interval_diff.html#see-also",
    "title": "interval_diff",
    "section": "",
    "text": "genominterv.intervals.interval_union, genominterv.intervals.interval_intersect, genominterv.intervals.interval_collapse.",
    "crumbs": [
      "Genomic set operations",
      "interval_diff"
    ]
  }
]