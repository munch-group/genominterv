[
  {
    "objectID": "api/foo.html",
    "href": "api/foo.html",
    "title": "foo",
    "section": "",
    "text": "genominterv.foo(x, y=1)\nThe sum of two numbers.\n\n\n\nx : int\n\nThe first number\n\ny :  = 1\n\nThe second number.\n\n\n\n\n\n\n : int\n\nSum of two numbers.\n\n\n\n\n\nscripts.bar : “Printing hello world”."
  },
  {
    "objectID": "api/foo.html#parameters",
    "href": "api/foo.html#parameters",
    "title": "foo",
    "section": "",
    "text": "x : int\n\nThe first number\n\ny :  = 1\n\nThe second number."
  },
  {
    "objectID": "api/foo.html#returns",
    "href": "api/foo.html#returns",
    "title": "foo",
    "section": "",
    "text": ": int\n\nSum of two numbers."
  },
  {
    "objectID": "api/foo.html#see-also",
    "href": "api/foo.html#see-also",
    "title": "foo",
    "section": "",
    "text": "scripts.bar : “Printing hello world”."
  },
  {
    "objectID": "api/interval_collapse.html",
    "href": "api/interval_collapse.html",
    "title": "interval_collapse",
    "section": "",
    "text": "genominterv.interval_collapse(interv)\nThis function computes the union of intervals in a single set.\n\n\n\ninterv : pandas.DataFrame\n\nData frame with intervals.\n\n\n\n\n\n\n : pandas.DataFrame\n\nA data frame with chr, start, end columns representing the union.\n\n\n\n\n\ngenominterv.interval_diff, genominterv.interval_union, genominterv.interval_intersect.",
    "crumbs": [
      "Some section",
      "interval_collapse"
    ]
  },
  {
    "objectID": "api/interval_collapse.html#parameters",
    "href": "api/interval_collapse.html#parameters",
    "title": "interval_collapse",
    "section": "",
    "text": "interv : pandas.DataFrame\n\nData frame with intervals.",
    "crumbs": [
      "Some section",
      "interval_collapse"
    ]
  },
  {
    "objectID": "api/interval_collapse.html#returns",
    "href": "api/interval_collapse.html#returns",
    "title": "interval_collapse",
    "section": "",
    "text": ": pandas.DataFrame\n\nA data frame with chr, start, end columns representing the union.",
    "crumbs": [
      "Some section",
      "interval_collapse"
    ]
  },
  {
    "objectID": "api/interval_collapse.html#see-also",
    "href": "api/interval_collapse.html#see-also",
    "title": "interval_collapse",
    "section": "",
    "text": "genominterv.interval_diff, genominterv.interval_union, genominterv.interval_intersect.",
    "crumbs": [
      "Some section",
      "interval_collapse"
    ]
  },
  {
    "objectID": "api/bar.baz.html",
    "href": "api/bar.baz.html",
    "title": "bar.baz",
    "section": "",
    "text": "bar.baz\ngenominterv.bar.baz()"
  },
  {
    "objectID": "api/interval_intersect.html",
    "href": "api/interval_intersect.html",
    "title": "interval_intersect",
    "section": "",
    "text": "genominterv.interval_intersect(query, annot)\nThis function computes the intersection of two sets of genomic intervals. The genomic intervals in each set must be non-overlapping. This can be achieved using interval_collapse.\n\n\n\nquery : pandas.DataFrame\n\nData frame with query intervals.\n\nannot : pandas.DataFrame\n\nData frame with annotation intervals.\n\n\n\n\n\n\n : pandas.DataFrame\n\nA data frame with chr, start, end columns representing the intersection.\n\n\n\n\n\ngenominterv.interval_diff, genominterv.interval_union, genominterv.interval_collapse.",
    "crumbs": [
      "Some section",
      "interval_intersect"
    ]
  },
  {
    "objectID": "api/interval_intersect.html#parameters",
    "href": "api/interval_intersect.html#parameters",
    "title": "interval_intersect",
    "section": "",
    "text": "query : pandas.DataFrame\n\nData frame with query intervals.\n\nannot : pandas.DataFrame\n\nData frame with annotation intervals.",
    "crumbs": [
      "Some section",
      "interval_intersect"
    ]
  },
  {
    "objectID": "api/interval_intersect.html#returns",
    "href": "api/interval_intersect.html#returns",
    "title": "interval_intersect",
    "section": "",
    "text": ": pandas.DataFrame\n\nA data frame with chr, start, end columns representing the intersection.",
    "crumbs": [
      "Some section",
      "interval_intersect"
    ]
  },
  {
    "objectID": "api/interval_intersect.html#see-also",
    "href": "api/interval_intersect.html#see-also",
    "title": "interval_intersect",
    "section": "",
    "text": "genominterv.interval_diff, genominterv.interval_union, genominterv.interval_collapse.",
    "crumbs": [
      "Some section",
      "interval_intersect"
    ]
  },
  {
    "objectID": "pages/overview.html",
    "href": "pages/overview.html",
    "title": "Overview",
    "section": "",
    "text": "genomeinterv provides support for working with intervals on genomes. A genomic interval is specified as a chromosome, start, and end. It is half-open so that a value x is in an interval (start, end) included in the inrval if start &lt;= x and x &lt; end. All functions take pandas.DataFrame as arguments. These data frames must include chrom, start, and end columns.\nSee the the library reference for detailed documentation of each function and decorator.",
    "crumbs": [
      "Overview"
    ]
  },
  {
    "objectID": "pages/overview.html#set-operations",
    "href": "pages/overview.html#set-operations",
    "title": "Overview",
    "section": "Set operations",
    "text": "Set operations\nThe three functions, interval_diff, interval_intersect, and interval_union, do the standard difference, intersection and union set operations on two sets of genomic intervals. The intervals returned from all three functions are collapsed to produce non-overlapping intervals. The genomic intervals in each set must be non-overlapping. This can be achieved using the interval_collapse function, which produces the union of genomic intervals in a single set genomic ofintervals.",
    "crumbs": [
      "Overview"
    ]
  },
  {
    "objectID": "pages/overview.html#genomic-decorator",
    "href": "pages/overview.html#genomic-decorator",
    "title": "Overview",
    "section": "Genomic decorator",
    "text": "Genomic decorator\nTo make it easy to create other interval functions that work across chromosomes, the module provides a genomic decorator that can be applied to functions that operate lists of (start, end) tuples. Applying the decorator changes the signature of a function to make it operate on DataFrames that include chrom, start, and end columns. Here is an example function that shifts intervals by 1000bp:\n@genomic\ndef inverval_shift(tuples):\n    return [(x+1000, y+1000) for (x, y) in tuples]\n\ndf = pandas.DataFrame()\n\nshifted = inverval_shift(df)",
    "crumbs": [
      "Overview"
    ]
  },
  {
    "objectID": "pages/overview.html#remapping-functions",
    "href": "pages/overview.html#remapping-functions",
    "title": "Overview",
    "section": "Remapping functions",
    "text": "Remapping functions\nThe function interval_distance converts coordinates of one set of genomic intervals into distances to the closest interval in a second set. interval_relative_distance does the same but returns relative distances.",
    "crumbs": [
      "Overview"
    ]
  },
  {
    "objectID": "pages/overview.html#two-set-statistics",
    "href": "pages/overview.html#two-set-statistics",
    "title": "Overview",
    "section": "Two-set statistics",
    "text": "Two-set statistics\nThe module also provides two statistics for relations between sets: jaccard computes the Jaccard index statistic for two sets of genomic intervals.",
    "crumbs": [
      "Overview"
    ]
  },
  {
    "objectID": "pages/overview.html#bootstrap-decorator",
    "href": "pages/overview.html#bootstrap-decorator",
    "title": "Overview",
    "section": "Bootstrap decorator",
    "text": "Bootstrap decorator\nThe module provides a bootstrap decorator that turns a function producing a statistic into one that also produces a p-value. The bootstrapping resamples the intervals of the second argument for each chromosome independently. Only required argument to bootstrap is the name of the chromosome assembly used.\nThis example does this for the provided jaccard statistic\n@bootstrap('hg19', samples=1000)\ndef jaccard_test(query, annot):\n    return jaccard(query, annot)\n\njaccard_stat, p_value = jaccard_test(intervals, other_intervals)\nThe decorator works on any function that takes two sets of intervals.",
    "crumbs": [
      "Overview"
    ]
  },
  {
    "objectID": "pages/overview.html#ready-made-tests",
    "href": "pages/overview.html#ready-made-tests",
    "title": "Overview",
    "section": "Ready-made tests",
    "text": "Ready-made tests\nproximity_test computes tests if intervals in one set is significantly proximal to intervals in another set.",
    "crumbs": [
      "Overview"
    ]
  },
  {
    "objectID": "pages/overview.html#learning-more",
    "href": "pages/overview.html#learning-more",
    "title": "Overview",
    "section": "Learning more",
    "text": "Learning more\nGo to the anvanced page to learn how to …\n\nExamples page: sites using quartodoc.",
    "crumbs": [
      "Overview"
    ]
  },
  {
    "objectID": "pages/something.html",
    "href": "pages/something.html",
    "title": "Some other use case",
    "section": "",
    "text": "Import some plotting libraries and set some defaults:\n%config InlineBackend.figure_formats = ['svg']\nparams = load_params('../global_params.yml')\nparams\n\n{'questions': ['Blah blah blah',\n               'Blah blah blah',\n               'Blah blah blah',\n               'Blah blah blah'],\n 'sample_size': 24}\nparams.sample_size\n\n24"
  },
  {
    "objectID": "pages/something.html#sampling",
    "href": "pages/something.html#sampling",
    "title": "Some other use case",
    "section": "Sampling",
    "text": "Sampling\n\nsubjects = pd.read_csv('../data/data_table.csv')\nassert subjects.index.size == params.sample_size\n\n\nTip:\nBy adding a label and caption to a cell displaying a table, you can refer to that table elsewhere and insert it in a manuscript.\n\n\nsubjects\n\n\n\nTable 1: People included in the analysis.\n\n\n\n\n\n\n\n\n\n\nname\nage\nsex\nposition\nnationality\n\n\n\n\n0\nJulie\n27\nF\nPhDstudent\nDK\n\n\n1\nThomas\n33\nM\nPostdoc\nGB\n\n\n2\nEmilie\n23\nF\nPhDstudent\nCH\n\n\n3\nSofie\n31\nF\nPostdoc\nDK\n\n\n4\nSara\n29\nF\nPostdoc\nUS\n\n\n5\nCecilie\n34\nF\nPostdoc\nDK\n\n\n6\nAnders\n32\nM\nPhDstudent\nUK\n\n\n7\nEmma\n42\nF\nProfessor\nDK\n\n\n8\nCaroline\n31\nF\nPhDstudent\nDK\n\n\n9\nLaura\n30\nF\nPostdoc\nDK\n\n\n10\nMikkel\n33\nM\nPostdoc\nNL\n\n\n11\nJens\n27\nM\nPhDstudent\nDK\n\n\n12\nAndreas\n29\nM\nPhDstudent\nDK\n\n\n13\nJakob\n28\nM\nPhDstudent\nDK\n\n\n14\nMathilde\n61\nF\nProfessor\nDK\n\n\n15\nKatrine\n35\nF\nPostdoc\nDK\n\n\n16\nPoul\n30\nM\nPostdoc\nDK\n\n\n17\nAnna\n26\nF\nPhDstudent\nDK\n\n\n18\nPeter\n42\nM\nProfessor\nGB\n\n\n19\nIda\n53\nF\nPostdoc\nDK\n\n\n20\nFreja\n30\nF\nPostdoc\nDK\n\n\n21\nMaria\n39\nF\nProfessor\nUK\n\n\n22\nAmalie\n29\nF\nPhDstudent\nDK\n\n\n23\nCamilla\n35\nF\nPostdoc\nDK\n\n\n\n\n\n\n\n\n\n\n\nTip:\nBy generaing markdown for descriptions that will eventually end up in the manuscript, you can imbed python values. It also ensures that the manuscript exactly reflects the notebook.\n\n\n\nThe 24 subjects from workplaces in Denmark were interviewed …. blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah"
  },
  {
    "objectID": "pages/something.html#interviews",
    "href": "pages/something.html#interviews",
    "title": "Some other use case",
    "section": "Interviews",
    "text": "Interviews\n\n\nThe 24 subjects were asked to score the follow statements:\n\nBlah blah blah\nBlah blah blah\nBlah blah blah\nBlah blah blah"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "genominterv",
    "section": "",
    "text": "genominterv\nBlah blah…"
  },
  {
    "objectID": "pages/advanced.html",
    "href": "pages/advanced.html",
    "title": "Advanced use",
    "section": "",
    "text": "Etiam non efficitur urna, quis elementum nisi. Mauris posuere a augue vel gravida. Praesent luctus erat et ex iaculis interdum. Nulla vestibulum quam ac nunc consequat vulputate. Nullam iaculis lobortis sem sit amet fringilla. Aliquam semper, metus ut blandit semper, nulla velit fermentum sapien, fermentum ultrices dolor sapien sed leo. Vestibulum molestie faucibus magna, at feugiat nulla ullamcorper a. Aliquam erat volutpat. Praesent scelerisque magna a justo maximus, sit amet suscipit mauris tempor. Nulla nec dolor eget ipsum pellentesque lobortis a in ipsum. Morbi turpis turpis, fringilla a eleifend maximus, viverra nec neque. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos.\nMaecenas turpis velit, ultricies non elementum vel, luctus nec nunc. Nulla a diam interdum, faucibus sapien viverra, finibus metus. Donec non tortor diam. In ut elit aliquet, bibendum sem et, aliquam tortor. Donec congue, sem at rhoncus ultrices, nunc augue cursus erat, quis porttitor mauris libero ut ex. Nullam quis leo urna. Donec faucibus ligula eget pellentesque interdum. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean rhoncus interdum erat ut ultricies. Aenean tempus ex non elit suscipit, quis dignissim enim efficitur. Proin laoreet enim massa, vitae laoreet nulla mollis quis.",
    "crumbs": [
      "Advanced",
      "Advanced use"
    ]
  },
  {
    "objectID": "pages/advanced.html#some-topic",
    "href": "pages/advanced.html#some-topic",
    "title": "Advanced use",
    "section": "Some topic",
    "text": "Some topic\nFinding Python objects to document involves two pieces of configuration:\n\nthe package name.\na list of objects for content.\n\nquartodoc can look up a wide variety of objects, including functions, modules, classes, attributes, and methods:",
    "crumbs": [
      "Advanced",
      "Advanced use"
    ]
  },
  {
    "objectID": "pages/examples.html",
    "href": "pages/examples.html",
    "title": "genominterv - Genome Intervals",
    "section": "",
    "text": "genomeinterv provides support for working with intervals on genomes. A genomic interval is specified as a chromosome, start, and end. It is half-open so that a value x is in an interval (start, end) included in the inrval if start &lt;= x and x &lt; end. All functions take pandas.DataFrames as arguments. These data frames must include chrom, start, and end columns.\nSee the library reference for detailed documentation of each function and decorator.\nimport genominterv\nimport pandas as pd"
  },
  {
    "objectID": "pages/examples.html#set-operations",
    "href": "pages/examples.html#set-operations",
    "title": "genominterv - Genome Intervals",
    "section": "Set operations",
    "text": "Set operations\nThe three functions interval_diff, interval_intersect, and interval_union do the standard difference, intersection and union set operations on two sets of genomic intervals.\nThe intervals returned from all three functions are collapsed to produce non-overlapping intervals. The genomic intervals in each set must be non-overlapping. This can be achieved using function interval_collapse, which produces the union of genomic intervals in a single set genomic of intervals.\nTry it out on two sets of intervals: annot and query:\n\nintervals = [('chr1', 1, 3), ('chr1', 4, 10), ('chr1', 25, 30), ('chr1', 20, 27), ('chr2', 1, 10), ('chr2', 1, 3)]\nannot = pd.DataFrame.from_records(intervals, columns=['chrom', 'start', 'end'])\nannot\n\n\n\n\n\n\n\n\nchrom\nstart\nend\n\n\n\n\n0\nchr1\n1\n3\n\n\n1\nchr1\n4\n10\n\n\n2\nchr1\n25\n30\n\n\n3\nchr1\n20\n27\n\n\n4\nchr2\n1\n10\n\n\n5\nchr2\n1\n3\n\n\n\n\n\n\n\n\nintervals = [('chr1', 8, 22), ('chr2', 14, 15)]\nquery = pd.DataFrame.from_records(intervals, columns=['chrom', 'start', 'end'])\nquery\n\n\n\n\n\n\n\n\nchrom\nstart\nend\n\n\n\n\n0\nchr1\n8\n22\n\n\n1\nchr2\n14\n15\n\n\n\n\n\n\n\n\nfrom genominterv import interval_collapse\n\nannot_collapsed = interval_collapse(annot)\nannot_collapsed\n\n\n\n\n\n\n\n\nindex\nstart\nend\nchrom\n\n\n\n\n0\n0\n1\n3\nchr1\n\n\n1\n1\n4\n10\nchr1\n\n\n2\n2\n20\n30\nchr1\n\n\n3\n0\n1\n10\nchr2\n\n\n\n\n\n\n\n\nfrom genominterv import interval_diff\n\nnon_ovl_query = interval_diff(query, annot_collapsed)\nnon_ovl_query\n\n\n\n\n\n\n\n\nindex\nstart\nend\nchrom\n\n\n\n\n0\n0\n10\n20\nchr1\n\n\n1\n0\n14\n15\nchr2\n\n\n\n\n\n\n\n\nfrom genominterv import interval_intersect\n\nintersection = interval_intersect(query, annot_collapsed)\nintersection\n\n\n\n\n\n\n\n\nindex\nstart\nend\nchrom\n\n\n\n\n0\n0\n8\n10\nchr1\n\n\n1\n1\n20\n22\nchr1\n\n\n\n\n\n\n\n\nfrom genominterv import interval_union\n\nunion = interval_union(query, annot_collapsed)\nunion\n\n\n\n\n\n\n\n\nindex\nstart\nend\nchrom\n\n\n\n\n0\n0\n1\n3\nchr1\n\n\n1\n1\n4\n30\nchr1\n\n\n2\n0\n1\n10\nchr2\n\n\n3\n1\n14\n15\nchr2\n\n\n\n\n\n\n\nTo make it easy to create other interval functions that work across chromosomes, the module provides a genomic decorator that can be applied to functions that operate lists of (start, end) tuples. Applying the decorator changes the signature of a function to make it operate on DataFrames that include chrom, start, and end columns.\nHere is an example function that shifts the interval coordinates by 1000bp:\n\nintervals = pd.DataFrame(dict(chrom='chrX', start=[1, 20], end=[2, 25]))\nintervals\n\n\n\n\n\n\n\n\nchrom\nstart\nend\n\n\n\n\n0\nchrX\n1\n2\n\n\n1\nchrX\n20\n25\n\n\n\n\n\n\n\n\nfrom genominterv import genomic\n\n@genomic\ndef inverval_shift(interv):\n    return [(start+1000, end+1000) for (start, end) in interv]\n\nshifted = inverval_shift(intervals)\nshifted\n\n\n\n\n\n\n\n\nindex\nstart\nend\nchrom\n\n\n\n\n0\n0\n1001\n1002\nchrX\n\n\n1\n1\n1020\n1025\nchrX"
  },
  {
    "objectID": "pages/examples.html#remapping-functions",
    "href": "pages/examples.html#remapping-functions",
    "title": "genominterv - Genome Intervals",
    "section": "Remapping functions",
    "text": "Remapping functions\nThe function remap converts coordinates a single interval into distance to the closest interval in a second set:\n\nsingle_interval = (300, 400)\nother_intervals = [(0, 100), (1000, 1100)]\n\ngenominterv.remap(single_interval, other_intervals)\n\n[(200, 300)]\n\n\nSame but retaining info about which annotation the interval is proximal to:\n\ngenominterv.remap((300, 400), [(0, 100), (1000, 1100)], include_prox_coord=True)\n\n[(200, 300, 0, 100)]\n\n\nThe function interval_distance converts coordinates of one set of genomic intervals into distances to the closest interval in a second set. interval_relative_distance does the same but returns relative distances.\n\nannot = pd.DataFrame(dict(chrom='chrX', start=[1, 20], end=[2, 25]))\nannot\n\n\n\n\n\n\n\n\nchrom\nstart\nend\n\n\n\n\n0\nchrX\n1\n2\n\n\n1\nchrX\n20\n25\n\n\n\n\n\n\n\n\nquery = pd.DataFrame(dict(chrom='chrX', start=[3, 5], end=[15, 7], some_data=['foo', 'bar'], other_data=['A', 'B']))\nquery\n\n\n\n\n\n\n\n\nchrom\nstart\nend\nsome_data\nother_data\n\n\n\n\n0\nchrX\n3\n15\nfoo\nA\n\n\n1\nchrX\n5\n7\nbar\nB\n\n\n\n\n\n\n\n\nfrom genominterv import interval_distance\n\ninterval_distance(query, annot)\n\n\n\n\n\n\n\n\nindex\nstart\nend\nchrom\n\n\n\n\n0\n0\n1\n9\nchrX\n\n\n1\n1\n-5\n-9\nchrX\n\n\n2\n2\n3\n5\nchrX\n\n\n\n\n\n\n\n\nfrom genominterv import interval_relative_distance\n\ninterval_relative_distance(query, annot)\n\n\n\n\n\n\n\n\nindex\nstart\nend\nchrom\n\n\n\n\n0\n0\n0.055556\n0.500000\nchrX\n\n\n1\n1\n-0.277778\n-0.500000\nchrX\n\n\n2\n2\n0.166667\n0.277778\nchrX\n\n\n\n\n\n\n\nThe most useful function for most applications is remap_interval_data, which does the remapping while preserving all the information in the query data frame. It also reports the start and end coordinates before remapping (ends with *_orig) and the coordinates of the most proximal segment in the annotation set (*_prox).\n\nfrom genominterv import remap_interval_data\n\nremap_interval_data(query, annot)\n\n\n\n\n\n\n\n\nstart\nend\nstart_prox\nend_prox\nchrom\nstart_orig\nend_orig\nsome_data\nother_data\n\n\n\n\n0\n1\n9\n1\n2\nchrX\n3\n15\nfoo\nA\n\n\n1\n-5\n-9\n20\n25\nchrX\n3\n15\nfoo\nA\n\n\n2\n3\n5\n1\n2\nchrX\n5\n7\nbar\nB"
  },
  {
    "objectID": "pages/examples.html#ready-made-tests",
    "href": "pages/examples.html#ready-made-tests",
    "title": "genominterv - Genome Intervals",
    "section": "Ready-made tests",
    "text": "Ready-made tests\nproximity_test computes tests if intervals in one set is significantly proximal to intervals in another set.\n\nfrom genominterv import proximity_test\n\nannot = pd.DataFrame(dict(chrom='chr1',\n                          start=list(range(1, 1000, 100)),\n                          end=list(range(20, 1020, 100))))\nquery = pd.DataFrame(dict(chrom='chr1',\n                          start=list(range(1, 1000, 10)),\n                          end=list(range(10, 1010, 10))))\n\nThe annotation intervals cannot overlap each other or any of the query intervals:\n\nannot_collapsed = interval_collapse(annot)\nnon_ovl_query = interval_diff(query, annot_collapsed)\n\n\nproximity_test(non_ovl_query, annot_collapsed)\n\nTestResult(statistic=0.29842696629213444, pvalue=0.0)"
  },
  {
    "objectID": "pages/examples.html#two-set-statistics",
    "href": "pages/examples.html#two-set-statistics",
    "title": "genominterv - Genome Intervals",
    "section": "Two-set statistics",
    "text": "Two-set statistics\nThe module also provides two statistics for relations between sets: jaccard computes the Jaccard index statistic for two sets of genomic intervals.\n\nannot = pd.DataFrame(dict(chrom='chrX', start=[2, 9, 20], end=[4, 14, 25], some_data=['foo', 'bar', 'baz']))\nannot\n\n\n\n\n\n\n\n\nchrom\nstart\nend\nsome_data\n\n\n\n\n0\nchrX\n2\n4\nfoo\n\n\n1\nchrX\n9\n14\nbar\n\n\n2\nchrX\n20\n25\nbaz\n\n\n\n\n\n\n\n\nquery = pd.DataFrame(dict(chrom='chrX', start=[3, 7], end=[5, 10], some_data=['foo', 'bar'], other_data=['A', 'B']))\nquery\n\n\n\n\n\n\n\n\nchrom\nstart\nend\nsome_data\nother_data\n\n\n\n\n0\nchrX\n3\n5\nfoo\nA\n\n\n1\nchrX\n7\n10\nbar\nB\n\n\n\n\n\n\n\n\nfrom genominterv import jaccard\n\njaccard(query, annot)\n\n0.13333333333333333"
  },
  {
    "objectID": "pages/examples.html#bootstrap-decorator",
    "href": "pages/examples.html#bootstrap-decorator",
    "title": "genominterv - Genome Intervals",
    "section": "Bootstrap decorator",
    "text": "Bootstrap decorator\nThe module provides a bootstrap decorator that turns a function producing a statistic into one that also produces a p-value. The bootstrapping resamples the intervals of the second argument for each chromosome independently. Only required argument to bootstrap is the name of the chromosome assembly used. The decorator works on any function that takes two sets of intervals.\nThis example does this for the provided jaccard satistic:\n\nfrom genominterv import bootstrap\n\n@bootstrap('hg19', samples=1000)\ndef jaccard_test(query, annot):\n    return jaccard(query, annot)\n\njaccard_stat, p_value = jaccard_test(query, annot)\n\np-value is zero smaller than 0.001. Increase nr samples to get actual p-value."
  },
  {
    "objectID": "pages/basics.html",
    "href": "pages/basics.html",
    "title": "Basic use",
    "section": "",
    "text": "Etiam congue quam eget velit convallis, eu sagittis orci vestibulum. Vestibulum at massa turpis. Curabitur ornare ex sed purus vulputate, vitae porta augue rhoncus. Phasellus auctor suscipit purus, vel ultricies nunc. Nunc eleifend nulla ac purus volutpat, id fringilla felis aliquet. Duis vitae porttitor nibh, in rhoncus risus. Vestibulum a est vitae est tristique vehicula. Proin mollis justo id est tempus hendrerit. Praesent suscipit placerat congue. Aliquam eu elit gravida, consequat augue non, ultricies sapien. Nunc ultricies viverra ante, sit amet vehicula ante volutpat id. Etiam tempus purus vitae tellus mollis viverra. Donec at ornare mauris. Aliquam sodales hendrerit ornare. Suspendisse accumsan lacinia sapien, sit amet imperdiet dui molestie ut.\nNunc ac dignissim magna. Vestibulum vitae egestas elit. Proin feugiat leo quis ante condimentum, eu ornare mauris feugiat. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Mauris cursus laoreet ex, dignissim bibendum est posuere iaculis. Suspendisse et maximus elit. In fringilla gravida ornare. Aenean id lectus pulvinar, sagittis felis nec, rutrum risus. Nam vel neque eu arcu blandit fringilla et in quam. Aliquam luctus est sit amet vestibulum eleifend. Phasellus elementum sagittis molestie. Proin tempor lorem arcu, at condimentum purus volutpat eu. Fusce et pellentesque ligula. Pellentesque id tellus at erat luctus fringilla. Suspendisse potenti.",
    "crumbs": [
      "Basics",
      "Basic use"
    ]
  },
  {
    "objectID": "pages/basics.html#some-topic",
    "href": "pages/basics.html#some-topic",
    "title": "Basic use",
    "section": "Some topic",
    "text": "Some topic\nFinding Python objects to document involves two pieces of configuration:\n\nthe package name.\na list of objects for content.\n\nquartodoc can look up a wide variety of objects, including functions, modules, classes, attributes, and methods:",
    "crumbs": [
      "Basics",
      "Basic use"
    ]
  },
  {
    "objectID": "api/interval_union.html",
    "href": "api/interval_union.html",
    "title": "interval_union",
    "section": "",
    "text": "genominterv.interval_union(query, annot)\nThis function computes the union of two sets of genomic intervals. The genomic intervals in each set must be non-overlapping. This can be achieved using interval_collapse.\n\n\n\nquery : pandas.DataFrame\n\nData frame with query intervals.\n\nannot : pandas.DataFrame\n\nData frame with annotation intervals.\n\n\n\n\n\n\n : pandas.DataFrame\n\nA data frame with chr, start, end columns representing the union.\n\n\n\n\n\ngenominterv.interval_diff, genominterv.interval_intersect, genominterv.interval_collapse.",
    "crumbs": [
      "Some section",
      "interval_union"
    ]
  },
  {
    "objectID": "api/interval_union.html#parameters",
    "href": "api/interval_union.html#parameters",
    "title": "interval_union",
    "section": "",
    "text": "query : pandas.DataFrame\n\nData frame with query intervals.\n\nannot : pandas.DataFrame\n\nData frame with annotation intervals.",
    "crumbs": [
      "Some section",
      "interval_union"
    ]
  },
  {
    "objectID": "api/interval_union.html#returns",
    "href": "api/interval_union.html#returns",
    "title": "interval_union",
    "section": "",
    "text": ": pandas.DataFrame\n\nA data frame with chr, start, end columns representing the union.",
    "crumbs": [
      "Some section",
      "interval_union"
    ]
  },
  {
    "objectID": "api/interval_union.html#see-also",
    "href": "api/interval_union.html#see-also",
    "title": "interval_union",
    "section": "",
    "text": "genominterv.interval_diff, genominterv.interval_intersect, genominterv.interval_collapse.",
    "crumbs": [
      "Some section",
      "interval_union"
    ]
  },
  {
    "objectID": "api/interval_diff.html",
    "href": "api/interval_diff.html",
    "title": "interval_diff",
    "section": "",
    "text": "genominterv.interval_diff(query, annot)\nThis function computes the difference between two sets of genomic intervals. The genomic intervals in each set must be non-overlapping. This can be achieved using :any:interval_collapse.\n\n\n\nquery : pandas.DataFrame\n\nData frame with query intervals.\n\nannot : pandas.DataFrame\n\nData frame with annotation intervals.\n\n\n\n\n\n\n : pandas.DataFrame\n\nA data frame with chr, start, end columns representing the difference.\n\n\n\n\n\ngenominterv.interval_union, genominterv.interval_intersect, genominterv.interval_collapse.",
    "crumbs": [
      "Some section",
      "interval_diff"
    ]
  },
  {
    "objectID": "api/interval_diff.html#parameters",
    "href": "api/interval_diff.html#parameters",
    "title": "interval_diff",
    "section": "",
    "text": "query : pandas.DataFrame\n\nData frame with query intervals.\n\nannot : pandas.DataFrame\n\nData frame with annotation intervals.",
    "crumbs": [
      "Some section",
      "interval_diff"
    ]
  },
  {
    "objectID": "api/interval_diff.html#returns",
    "href": "api/interval_diff.html#returns",
    "title": "interval_diff",
    "section": "",
    "text": ": pandas.DataFrame\n\nA data frame with chr, start, end columns representing the difference.",
    "crumbs": [
      "Some section",
      "interval_diff"
    ]
  },
  {
    "objectID": "api/interval_diff.html#see-also",
    "href": "api/interval_diff.html#see-also",
    "title": "interval_diff",
    "section": "",
    "text": "genominterv.interval_union, genominterv.interval_intersect, genominterv.interval_collapse.",
    "crumbs": [
      "Some section",
      "interval_diff"
    ]
  },
  {
    "objectID": "api/index.html",
    "href": "api/index.html",
    "title": "Function reference",
    "section": "",
    "text": "interval_diff\nThis function computes the difference between two sets of genomic intervals.\n\n\ninterval_union\nThis function computes the union of two sets of genomic intervals. The genomic intervals\n\n\ninterval_intersect\nThis function computes the intersection of two sets of genomic intervals. The genomic intervals\n\n\ninterval_collapse\nThis function computes the union of intervals in a single set.",
    "crumbs": [
      "Library reference",
      "Function reference"
    ]
  },
  {
    "objectID": "api/index.html#some-section",
    "href": "api/index.html#some-section",
    "title": "Function reference",
    "section": "",
    "text": "interval_diff\nThis function computes the difference between two sets of genomic intervals.\n\n\ninterval_union\nThis function computes the union of two sets of genomic intervals. The genomic intervals\n\n\ninterval_intersect\nThis function computes the intersection of two sets of genomic intervals. The genomic intervals\n\n\ninterval_collapse\nThis function computes the union of intervals in a single set.",
    "crumbs": [
      "Library reference",
      "Function reference"
    ]
  }
]